[TABLE_OF_CONTENTS]
	[TABLE_OF_CONTENTS]	
	[TERMINOLOGY]
	[OVERVIEW]
		[GENERAL]
		[INSTRUCTION_LIST]
		[ALTERNATIVE_INSTRUCTION_LIST]
	[INSTRUCTION_ENCODING]
		[IMMEDIATE]
		[LONG_OPCODE]
			[IMMEDIATE] [REG_IMM] [RET_FLAGS]
		[SHORT_OPCODE]
			[LONG_IMMEDIATE] [JMP_CCC] [MOV_CCC] [REG_IMM]
			[REG_REG]
	[REGISTERS]
		[INTERNAL]
		[EXTERNAL]
			[LIST]
			[IP] [CF] [UI] [LR]
			[SP] [OF] [FL] [F1]
			[F2]
		[PRIVILEGED_EXTERNAL]
			[LIST]
			[DESCRIPTION]
		[IMPLEMENTATION]
	[CPU_FEATURES]
	[BOOT]
	[MEMORY]
		[GENERAL]
		[STACK]
		[VIRTUAL]
			[PID]
			[PAGE_TABLE]
				[LAYOUT]
				[UPDATE]
			[PAGE_FAULT]	
			[PROTECTION]
	[PRIVILEGE_LEVEL]
	[IO]
	[INTERRUPTS]
		[LIST]
		[PRECISE]
		[HANDLER_TABLE]
		[RAISED]
		[HANDLED]
		[HANDLER]
			[TIMER] [PAGE_FAULT] [PRIVILEGE_VIOLATION] [PERMISSION_VIOLATION]
			[DIVISION_BY_0] [IO_INTERRUPT] [INSTRUCTION_NOT_SUPPORTED] [SOFTWARE_INTERRUPT]
	[EXTENSIONS]
	[PERFORMANCE_MEASUREMENT]
	[INSTRUCTIONS]
		[ADD] [AND] [CAL] [CMP]
		[DIV] [HCF] [HLT] [INT]
		[IRT] [JCS] [JCU] [JMP]
		[MCS] [MCU] [MOV] [MRD]
		[MRO] [MUL] [MWR] [MWO]
		[NOP] [NOT] [ORR] [POP]
		[PRD] [PSH] [PWR] [PXR]
		[PXW] [RET] [SHL] [SHR]
		[SUB] [TST] [XOR] [XRD]
		[XWR]
	[EXPERIMENTAL]

	To navigate to particular section concatenate sections to one long tag with colons as separators
	for example to move to PAGE_FAULT search for [MEMORY:VIRTUAL:PAGE_FAULT]
	more than 1 section on the list is compressed view of list, at most 4 per line

[TERMINOLOGY]
	WORD
		2B wide 
		smallest addressable unit of data
	INTERNAL REGISTER
		general purpose register
		accessible by all instructions requiring register
		internal to register file
	EXTERNAL REGISTER
		special purpose register 
		can be modified with XWR and XRD
		external to register file
	PRIVILEGED_EXTERNAL_REGISTER
		special purpose register
		can be modified with PXW and PXR
		can only be modified in privileged mode
	IMPLEMENTATION REGISTER
		register used by implementation
		no way to access except for special instructions

[OVERVIEW]
	[OVERVIEW:GENERAL]
		version:            0 
		codename:           16b40
		this doc revision:  0 
		
		Future ISA versions will be backwards compatible unless bug is found 
		if ISA introduces breaking change, it will be stated very clearly 
		the exception is instruction encoding which *may* change if enough new instructions are needed
		however it will always be enough to disassemble old code and assemble it again to get functionally equivalent code that works with new encoding

		Extensions may be eventually merged into ISA and removed from CF register

		Negative numbers are represented in Two's complement form
	
	[OVERVIEW:INSTRUCTION_LIST]
		this view is primarily useful for user since all instructions are condensed 
		this view does not include unused instructions
		for view for implementation developer see [OVERVIEW:ALTERNATIVE_INSTRUCTION_LIST]

		Number in the opcode in hex
		fields with no instructions intentionally left blank
		 programs MUST NOT depend on their behavior since in the future the ISA may be extended

		##      P E
		01 000  D   int    imm8         	# interrupt imm8 
		01 001  P   irt    ----         	# return from interrupt
		01 010  P   hlt    ----         	# halts processor, waits for interrupts
		01 011  P   hcf    ----         	# halts processor completely 
		01 110  P   pxr    d, imm5      	# R[d] <-- PX[imm5]
		01 111  P   pxw    imm5, s      	# PX[imm5] <-- R[s] 
		02          cal       imm11     	# LR <-- IP ; IP <-- IP + imm16
		03          jmp       imm11     	# IP <-- IP + imm16
		04          jcu LEG   imm8      	# IF(flags) { IP <-- IP + imm16 } 
		05          jcs LEG   imm8      	# IF(flags) { IP <-- IP + imm16 }
		06 000    P                     	# programmable instruction #0 (only in REG_IMM format)
		   ...
		07 111    P                     	# programmable instruction #F (only in REG_IMM format)
		08      P   prd       d, s/imm8 	# R[d] <-- P[R[s]/imm16]
		09      P   pwr       d/imm8, s 	# P[R[d]/imm16] <-- R[d]
		0A          xrd       d, s      	# R[d] <-- E[s] (only in REG_REG format)
		0B          xwr       d, s/imm8 	# E[d] <-- R[s]/imm16
		0C          mrd       d, s/imm8 	# R[d] <-- M[R[s]/imm16]
		0D          mwr       d/imm8, s  	# M[R[d]/imm16] <-- R[s]
		0E          mro       d, s/imm8 	# R[d] <-- M[R[s]/imm16 + OF]
		0F          mwo       d/imm8, s 	# M[R[d]/imm16 + OF] <-- R[s]
		10        M mul       d, s/imm8 	# R[d] <-- R[d] *  R[s]/imm16
		11          cmp       d, s/imm8 	#          R[d] -  R[s]/imm16
		12        D div       d, s/imm8 	# R[d] <-- R[d] /  R[s]/imm16
		13          tst       d, s/imm8 	#          R[d] &  R[s]/imm16
		14          mov       d, s/imm8 	# R[d] <-- R[s]/imm16
		15 000      pop       d         	# R[d] <-- M[SP] ; SP <-- SP + 1 
		15 001      psh          s      	# SP <-- SP - 1 ; M[SP] <-- R[s]
		15 010      cal       s         	# LR <-- IP ; IP <-- R[s] 
		15 011      jmp       s         	# IP <-- R[s]
		15 100      ret       SOCZ      	# IP <-- LR; FL <-- SOCZ
		15 111      nop                 	# --------
		16        C mcu LEG   d, s      	# IF(flags) {R[d] <-- R[s]}
		17        C mcs LEG   d, s      	# IF(flags) {R[d] <-- R[s]}
		18          add       d, s/imm8 	# R[d] <-- R[d] +  R[s]/imm16
		19          sub       d, s/imm8 	# R[d] <-- R[d] -  R[s]/imm16
		1A          not       d, s/imm8 	# R[d] <--      ~  R[s]/imm16
		1B          and       d, s/imm8 	# R[d] <-- R[d] &  R[s]/imm16
		1C          orr       d, s/imm8 	# R[d] <-- R[d] |  R[s]/imm16
		1D          xor       d, s/imm8 	# R[d] <-- R[d] ^  R[s]/imm16
		1E          shl       d, s/imm8 	# R[d] <-- R[d] << R[s]/imm16
		1F          shr       d, s/imm8 	# R[d] <-- R[d] >> R[s]/imm16

		Where:
		M[x]  means memory at address x
		R[x]  means value of internal register x
		E[x]  means value of external register x
		P[x]  means value of port x
		PX[x] means value of privileged external register x 

		P in the P column implies that instruction has to be executed in privileged mode
		D in the P column implies that instruction MAY need to be executed in privileged mode, depending on operands
			see [PRIVILEGE_LEVEL]
		Letter in E column identifies necessary extensions to run instruction
			see [EXTENSIONS]

	[OVERVIEW:ALTERNATIVE_INSTRUCTION_LIST
		this view is primarily useful for implementation developer since all possible cases are visibly listed
		for view for user see [OVERVIEW:INSTRUCTION_LIST]

		XXXXX--- --------:
			00000--- ---XXXXX:    
				00000	    invalid           # will always be invalid
				00001	    invalid           #
				00010	    invalid           #
				00011	    invalid           #
				00100	    invalid           #
				00101	    invalid           #
				00110	    invalid           #
				00111	    invalid           #
				01000	P   prd       d, s    # R[d] <-- P[R[s]]
				01001	P   pwr       d, s    # P[R[d]] <-- R[d]
				01010	    xrd       d, s    # R[d] <-- E[s] 
				01011	    xwr       d, s    # E[d] <-- R[s]
				01100	    mrd       d, s    # R[d] <-- M[R[s]]
				01101	    mwr       d, s    # M[R[d]] <-- R[s]
				01110	    mro       d, s    # R[d] <-- M[R[s] + OF]
				01111	    mwo       d, s    # M[R[d] + OF] <-- R[s]
				10000	  M mul       d, s    # R[d] <-- R[d] *  R[s]
				10001	    cmp       d, s    #          R[d] -  R[s]
				10010	  D div       d, s    # R[d] <-- R[d] /  R[s]
				10011	    tst       d, s    #          R[d] &  R[s]
				10100	    mov       d, s    # R[d] <-- R[s]
				10101	    invalid           #
				10110	    invalid           #
				10111	    invalid           #
				11000	    add       d, s    # R[d] <-- R[d] +  R[s]
				11001	    sub       d, s    # R[d] <-- R[d] -  R[s]
				11010	    not       d, s    # R[d] <--      ~  R[s]
				11011	    and       d, s    # R[d] <-- R[d] &  R[s]
				11100	    orr       d, s    # R[d] <-- R[d] |  R[s]
				11101	    xor       d, s    # R[d] <-- R[d] ^  R[s]
				11110	    shl       d, s    # R[d] <-- R[d] << R[s]
				11111	    shr       d, s    # R[d] <-- R[d] >> R[s]
			00001XXX --------:
				000  	D   int       imm8    # causes interrupt imm8 
				001  	P   irt               # returns from interrupt
				010  	P   hlt               # halts processor, waits for interrupts
				011  	P   hcf               # halts processor completely
				100  	    invalid           #
				101  	    invalid           #
				110  	P   pxr       d, imm5 # R[d] <-- PX[imm5]
				111  	P   pxw       imm5, s # PX[imm5] <-- R[s]
			00010    	    cal       imm11   # LR <-- IP ; IP <-- IP + imm16
			00011    	    jmp       imm11   # IP <-- IP + imm16
			00100    	    jcu LEG   imm8    # IF(flags) { IP <-- IP + imm16 } 
			00101    	    jcs LEG   imm8    # IF(flags) { IP <-- IP + imm16 }
			00110000 	  P                   # programmable instruction #0
			0011....
			00111111 	  P                   # programmable instruction #F
			01000    	P   prd       d, imm8 # R[d] <-- P[imm16]
			01001    	P   pwr       imm8, s # P[imm16] <-- R[d]
			01010    	    invalid
			01011    	    xwr       d, imm8 # E[d] <-- R[s]/
			01100    	    mrd       d, imm8 # R[d] <-- M[imm16]
			01101    	    mwr       imm8, s # M[imm16] <-- R[s]
			01110    	    mro       d, imm8 # R[d] <-- M[imm16 + OF]
			01111    	    mwo       imm8, s # M[imm16 + OF] <-- R[s]
			10000    	  M mul       d, imm8 # R[d] <-- R[d] *  imm16
			10001    	    cmp       d, imm8 #          R[d] -  imm16
			10010    	  D div       d, imm8 # R[d] <-- R[d] /  imm16
			10011    	    tst       d, imm8 #          R[d] &  imm16
			10100    	    mov       d, imm8 # R[d] <-- R[s]
			10101    	
				10101XXX --------:
				000  	    pop       d       # R[d] <-- M[SP] ; SP <-- SP + 1 
				001  	    psh          s    # SP <-- SP - 1 ; M[SP] <-- R[s]
				010  	    cal       s       # LR <-- IP ; IP <-- IP + R[s] 
				011  	    jmp       s       # IP <-- IP + R[s]
				100  	    ret       SOCZ    # IP <-- LR; FL <-- SOCZ
				101  		invalid
				110  		invalid
				111  	    nop               # --------
			10110    	  C mcu LEG   d, s    # IF(flags) {R[d] <-- R[s]}
			10111    	  C mcs LEG   d, s    # IF(flags) {R[d] <-- R[s]}
			11000    	    add       d, imm8 # R[d] <-- R[d] +  imm16
			11001    	    sub       d, imm8 # R[d] <-- R[d] -  imm16
			11010    	    not       d, imm8 # R[d] <--      ~  imm16
			11011    	    and       d, imm8 # R[d] <-- R[d] &  imm16
			11100    	    orr       d, imm8 # R[d] <-- R[d] |  imm16
			11101    	    xor       d, imm8 # R[d] <-- R[d] ^  imm16
			11110    	    shl       d, imm8 # R[d] <-- R[d] << imm16
			11111    	    shr       d, imm8 # R[d] <-- R[d] >> imm16
	
[INSTRUCTION_ENCODING]
	[INSTRUCTION_ENCODING:IMMEDIATES]
		bits in the immediate are encoded as follows
			let X be length of immediate
			MSb: X-2...0 X-1 :LSb
		in other words, Most significant bit comes LAST in the encoding
		all other bits are in the decreasing order
		for example, bits for 8bit immediate may organized like this:
			65432107
		this way sign extension is much simpler for implementation


		immediates are sign extended by 
			JMP, JCS, JCU, CAL
		all other instructions zero extend their immediate

		if XWR UI precedes an instruction with an immediate then 
			lower 8 bits of UI are shifted to the left 
			and merged with LOWER 8 bits of immediate
			which means that JMP and CAL will act as if they have 8 bit immediate, not 11

	[INSTRUCTION_LIST:LONG_OPCODE]
		this instructions have opcode 0x0, 0x6 and 0x7 and 0x15 in [INSTRUCTION_ENCODING:SHORT_OPCODE] format
	
		[INSTRUCTION_LIST:LONG_OPCODE:IMMEDIATE]
			OOOOOOOO IIIIIIII	
				O - opcode 
				I - imm8 

			used by:
				INT, IRT, HLT, HCF, NOP
				note that IRT, HLT, HCF, NOP ignore immediate, it should be set to 0

		[INSTRUCTION_LIST:LONG_OPCODE:REG_IMM]
			OOOOOOOO RRRIIIII
				O - opcode
				R - register id 
				I - imm5 
				
			used by:
				PXR, PXW, POP, PSH, CAL, JMP
				note that POP, PSH, CAL, JMP ignore immediate, it should be set to 0
				          this refers to CAL and JMP in register format

		[INSTRUCTION_LIST:LONG_OPCODE:RET_FLAGS]
			OOOOOOOO FFFF0000
				O - opcode
				F - SOCZ 
				0 - must be set to 0
				
			used by:
				RET

	[INSTRUCTION_ENCODING:SHORT_OPCODE]
		[INSTRUCTION_ENCODING:SHORT_OPCODE:LONG_IMMEDIATE]
			OOOOOIII IIIIIIII
				O - opcode
				I - imm11

			used by:
				JMP, CAL
				note that this refers to immediate version of these instructions
		
		[INSTRUCTION_ENCODING:SHORT_OPCODE:JMP_CCC]
			OOOOOIII IIIIFFFI
				O - opcode
				I - imm7
				F - flags, in order from MSb to LSb: SOCZ

			used by:
				JCS, JCU

		[INSTRUCTION_ENCODING:SHORT_OPCODE:MOV_CCC]
			OOOOOSSS DDD0FFF0
				O - opcode
				S - source register id
				D - destination register id
				F - flags, in order from MSb to LSb: SOCZ
				0 - MUST be 0
			
			used by:
				MCC, MNC

		[INSTRUCTION_ENCODING:SHORT_OPCODE:REG_IMM]
			OOOOOIII RRRIIIII
				O - opcode
				I - imm8
				R - register

			used by:
				PRD, PWR,      XWR, MRD, MWD, MRO,
				MWO, MUL, CMP, DIV, TST, MOV, ADD,
				SUB, NOT, AND, ORR, XOR, SHL, SHR
				note that this refers to immediate version of these instructions

		[INSTRUCTION_ENCODING:SHORT_OPCODE:REG_REG]
			00000SSS DDDOOOOO
				0 - MUST be set to 0
				S - source register
				D - destination register
				O - opcode

			used by:
				PRD, PWR, XRD, XWR, MRD, MWD, MRO,
				MWO, MUL, CMP, DIV, TST, MOV, ADD,
				SUB, NOT, AND, ORR, XOR, SHL, SHR
				note that this refers to register version of these instructions
[REGISTERS]
	[REGISTERS:INTERNAL]
		there are 8 registers available to be used in most of the instructions
		denoted by R[x] in instruction description 
		
		0 - R0 ; General Purpose Register 0
		1 - R1 ; General Purpose Register 1
		2 - R2 ; General Purpose Register 2
		3 - R3 ; General Purpose Register 3
		4 - R4 ; General Purpose Register 4
		5 - R5 ; General Purpose Register 5
		6 - R6 ; General Purpose Register 6
		7 - R7 ; General Purpose Register 7

	[REGISTERS:EXTERNAL]
		[REGISTERS:EXTERNAL:LIST]
			0 IP Instruction Pointer
			1 CF Cpu Flags (during Read)
			1 UI Upper Immediate (during Write)
			2 LR Link Register
			3 SP Stack Pointer
			4 OF OFfset register
			5 FL FLags
			6 F1 Feature enable 1  
			7 F2 Feature enable 2 

		[REGISTERS:EXTERNAL:IP] Instruction Pointer
			holds address of NEXT instruction
			writing to this register is equivalent to unconditional jump
				this is the only way to perform jump to absolute address

			if instruction was any of: INT, JMP CAL 
			or if instruction was JCS or JCU and the jump occurred 
			or if instruction was XWR IP, /*something*/
			then value of IP is changed by that instruction
			otherwise, it is incremented by 1 

		[REGISTERS:EXTERNAL:CF] CPU flags
			this register cannot be written into

			each bit contains info whether an extension is available
			see [CPU_FEATURES]

		[REGISTERS:EXTERNAL:UI] Upper Immediate
			this register cannot be read from directly
			it is possible to retrieve the value by using MOV R, IMM ; SHR R, 8

			extends range of immediate by adding additional 8 bits
			note that some instructions may ignore extended part completely
			cleared on each cycle it is not updated by instruction
			see [INSTRUCTION_ENCODING:IMMEDIATE] for details

		[REGISTERS:EXTERNAL:LR] Link Register
			used implicitly by CAL and RET
			CAL stores value of IP during CAL into LR
			in other words, CAL stores address of FOLLOWING instructions into LR

		[REGISTERS:EXTERNAL:SP] Stack Pointer
			used implicitly by POP and PSH

			see [MEMORY:STACK]

		[REGISTERS:EXTERNAL:OF] OFfset register
			used implicitly by MRO and MWO to access memory

		[REGISTERS:EXTERNAL:FL] FLags register
			contains 4 flag bits
			 00000000 0000SOCZ
			 S - most significant bit (sign) on 
			 O - signed overflow, defined for ADD, SUB, CMP
			 C - unsigned overflow, defined for ADD, SUB, CMP
			 Z - all bits = 0 
			 

		[REGISTERS:EXTERNAL:F1] Feature enable 1
			contains bit used to enable/disable particular feature, if available
			unused bits are reserved and their value should not be changed

			see [CPU_FEATURES]

		[REGISTERS:EXTERNAL:F2] Feature enable 2
			contains bit used to enable/disable particular feature, if available
			unused bits are reserved and their value should not be changed

			see [CPU_FEATURES]

	[REGISTERS:PRIVILEGED_EXTERNAL]
		to access any of these, [PRIVILEGE_LEVEL] must be 1 
		unused (and unlisted) registers MUST NOT be used, they are reserved for future use

		[REGISTERS:PRIVILEGED_EXTERNAL:LIST]
			01 page table address 
			02 available memory (in kiW), read only
			03 CPU feature flag
			10 interrupt info: id
			11 interrupt info: IP
			12 interrupt info: interrupt dependent 0
			13 interrupt info: interrupt dependent 1
			14 interrupt info: interrupt dependent 2
			31 update state, write only register, causes update to machine state (reread of state registers, reread of PT), write only
		[REGISTERS:PRIVILEGED_EXTERNAL:DESCRIPTION]
			PX[ 0]
				PID, need to be reloaded by PX[31] upon update

			PX[ 1]
				page table address

				see [MEMORY:VIRTUAL]
			PX[ 2]
				available memory, cannot be written 

			PX[ 3]
				CPU feature flag 

				0 - fast load 
					if set, OS does not need to load program from disk as it is loaded automatically

			PX[10] 
				interrupt ID

				see [INTERRUPTS]
			PX[11] 
				IP saved by interrupt

				see [INTERRUPTS]
			PX[12] 
				interrupt info 

				see [INTERRUPTS]
			PX[13]
				interrupt info 

				see [INTERRUPTS]
			PX[14]
				interrupt info 

				see [INTERRUPTS]
			PX[31]
				TO BE FINISHED
				state update
				write of particular bits causes update of machine state
				necessary after write to other PX that modifies machine state
				(or after write to several PX)
				note that write to this register may take many cycles, depending on how much HW has to do 

				bits from most significant bit to least are responsible for following updates
					15 - 
					14 - 
					13 - 
					12 - 
					11 - 
					10 - 
					 9 - 
					 8 - 
					 7 - 
					 6 - 
					 5 - disable interrupts
					 4 - enable interrupts
					 3 - flush PT
					 2 - lower privilege level
					 1 - interrupt handler table reload 
					 0 - PID reload 
				
				disable interrupts takes priority over enable

	[REGISTERS:IMPLEMENTATION]
		since these registers are implementation specific, they are not described here 
		check corresponding microarchitecture manual 

[CPU_FEATURES]
	TO BE FINISHED

	F1: 00000000 000000SB
	F2: 00000000 0000000P

	B [CPU_FEATURES:BIG_INT] 
		switch behavior of ADD and SUB to ADC and SBC
	P [CPU_FEATURES:SELF_MODIFYING_CODE_PROTECTION]
		when disabled, self modifying code MAY not work 
		but performance MAY improve
	S [CPU_FEATURES_SIGNED_ARITHMETIC]
		when enabled MUL, DIV and SHR treat operands as signed 
		does not apply to ADD and SUB which behave the same way either way

[BOOT]
	TO BE FINISHED
	boot:
		machine starts executing instructions from 0x0000 in privileged, unpaged mode

[MEMORY]
	[MEMORY:GENERAL]
		memory is word addressable, where each word is 2Bytes
		
		at least 64kiW (128kiB) is available

		memory can be accessed directly with:
			MRD MWD MRO MWO 
		or indirectly with
			PSH POP
		as well as instruction fetch

	[MEMORY:STACK]
		managed implicitly by POP and PSH
		SP points to the top of the stack
			NOT to where next value should go

		POP first gets value THEN increments SP
		PSH first decrements SP THEN puts value
		
		local variables can easily be accessed with [EXTERNAL_REGISTER:OF] set to SP

	[MEMORY:VIRTUAL]
		each page is 2kiB in size, thus full PT stores mapping for 32 pages

		on boot, paging is disabled
		first write that updates PID to PX[31] will also enable paging

		after that OS should setup its own page table to have access to more memory
		PT can be stored anywhere in virtual memory but must be in 0th frame
			see [MEMORY:VIRTUAL:PAGE_TABLE:LAYOUT] for format

		PHYSICAL address of PT is then saved into PX[1]
		then OS writes to PX[31] (see [REGISTERS:PRIVILEGED_EXTERNAL])

		it is impossible to disable paging after it has been enabled

		[MEMORY:VIRTUAL:PID]
			must be located at PHYSICAL address 0xFF

			CPU may be able to cache PT of more than 1 process at once 
			it is therefore necessary for CPU to distinguish different processes
			upon PT update, CPU also updates current PID from memory at address 0x00FF

		[MEMORY:VIRTUAL:PAGE_TABLE]
			[MEMORY:VIRTUAL:PAGE_TABLE:LAYOUT]
				each entry is 1W (16b) 

				32 entries, 1 for each page, ordered 
				[present] [read] [write] [execute] [frame #]
					  1b     1b      1b        1b       12b 

				if frame # exceeds physically available pages, the behavior is undefined
				os should make sure that a particular page is available via checking contents of PX[2]
				however, ISA guarantees that at least 64kiW are available (PX[2] >= 64)

			[MEMORY:VIRTUAL:PAGE_TABLE:UPDATE]
				if entry was NOT mapped
					no action other than updating is required 
				if entry was     mapped 
					OS MUST flush current PT (PX[31]) after PT update is finished 
					otherwise HW may use old mapping

		[MEMORY:VIRTUAL:PAGE_FAULT]	
			if program attempts to access page that is not present in page table,
			interrupt is generated and the control is passed to OS
			later instruction (or instruction pair, in case of preceding XWR UI) can be restarted

		[MEMORY:VIRTUAL:PROTECTION]
			each page entry contains bits for read, write, execute access
			if process tries to do any action which it cannot based on page table entry
			the interrupt is raised 
			
			if processor is running in privileged mode, this check is skipped 

[PRIVILEGE_LEVEL]
	controlled by internal register

	currently, there are 2 modes available
	supervisor mode (also referred to as privileged mode)
		enabled on boot and on interrupt 
	user mode, (also referred to as unprivileged mode)
	 	enabled by specific writing to PX[31]

[IO]
	TO BE FINISHED
	preferred method of communication with devices 

	devices and OS use port 0 to decide which ports are to be used 

[INTERRUPTS]
	while there is distinction between exceptions, interrupts, faults and traps
	this ISA treats them the same and thus they are collectively referred to as interrupts
	whenever distinction is needed, terms `external interrupt` for interrupt or `internal interrupt` for exceptions, faults or traps are used  
	
	INT instruction can cause any kind of interrupt
	however if the interrupt is in range {0; ...; 63} then it can only be run in privileged mode
	rationale is that there is no reason to allow user programs to raise these interrupts
	but system calls can be implemented via interrupts so unprivileged code should be able to call them

	if INT raises any HW defined interrupt, contents of PX[12..14] are undefined
	due to above and INT 0x01 behavior (see [INTERRUPTS:PRECISE])
	raising HW interrupts by INT instruction should almost definitely be avoided

	[INTERRUPTS:LIST]
		0 to 63   - HW defined (unused are reserved)
		64 to 255 - available to SW 
			OS can set them up for various syscalls instead of wasting register to decide that 

		0 - timer, EXTERNAL
		1 - page fault
		2 - privilege violation (privileged instruction in unprivileged mode)
		3 - permission violation (unallowed read/write/execute)
		4 - division by 0  
		5 - IO interrupt, EXTERNAL
		6 - instruction not supported
			TO BE FINISHED

	[INTERRUPTS:ORDERING]
		if more than 1 INTERNAL interrupt happen during execution of instruction
			the one with lower id takes priority, the other is lost
			there is no case where that would be a problem since page fault causes restart of instruction
		if more than 1 EXTERNAL interrupt happen during execution  
			the one with lower id takes priority, the other is delayed
		if EXTERNAL and INTERNAL interrupts happen during execution of instruction
			EXTERNAL is delayed until no INTERNAL interrupt takes place

	[INTERRUPTS:PRECISE]
		all interrupts, except INT 0x01, caused by INT instruction happen precisely between INT and next instruction
		meaning that IP saved in PX[11] is of NEXT instruction 
		INT 0x01, sets up PX[11] as defined by PAGE_FAULT, this means that INT 0x01 WILL cause infinite loop if used 
		
		list of HW interrupts that happen between instruction causing interrupt and next instruction 
			page fault
			privilege violation
			permission violation
			division by 0
			instruction not supported
			double fault 

		all other may occur on ANY instruction in the instruction stream 
		this is to simplify HW and allow for faster execution
		however it is guaranteed that interrupt will happen at most 10us later than it would if it was precise
		TO BE FINISHED timing

	[INTERRUPTS:HANDLER_TABLE]
		IHT is 256x1word table where each entry is an address of interrupt handler
		whenever interrupt with id N occurs, HW looks up Nth entry and jumps to address stored there

		IHT is specified by setting up table at address 0x0100 then updating HW state with PX[31] (see [REGISTERS:PRIVILEGED_EXTERNAL])
		HW loads IHT to internal registers and IHT in memory that was setup by SW is not needed anymore and is free to be removed
		it is not possible to modify single entry only

	[INTERRUPTS:RAISED]
		source of interrupt does not matter, basic handling looks the same 
		it may happen that several interrupts are to be raised, in which case, the lowest number takes priority
		
		when interrupt occurs during execution of instruction, that instruction completes THEN 
			interrupt is raised immediately
			interrupts are disabled
			necessary data is saved into PX and internal registers (see below)
			privilege level is raised if necessary
			jump into interrupt handler occurs and execution resumes

		saved data
			PX[10] = interrupt id
			PX[11] = address of instruction
			         unless specified otherwise, instruction to be executed AFTER interrupt causing one
			PX[12...14] = interrupt dependent info 


	[INTERRUPTS:HANDLED]
		interrupts can, but dont have to, be finished with IRT 
		OS may save IP for its own use and then reenable interrupts
		this way, longer syscalls can be implemented without disabling interrupts for too long
		 note that this is not possible for HW generated interrupts 
		 since they can occur in between XWR UI and instruction that uses immediate
		 however SW interrupt is always exactly after INT instruction

		handlers of HW interrupts almost definitely should end in IRT
		syscalls however are notable example which should not end in IRT

		during IRT
			privilege level is restored  
			UI is restored from internal register
			IP is restored from PX[11]
			interrupts are enabled
		
	[INTERRUPTS:HANDLER]
		there is no limit on interrupt handler length
		it is however advised that interrupt handlers are very short because they block other interrupts
		 while it is possible to reenable interrupts within interrupt handle, dont
		 there is no way to restore some of the state saved on interrupt other than IRT
		IHT entries can overlap like cases in switch statements in C
		
		exact behavior depends on interrupt
		
		
		[INTERRUPTS:HANDLER:TIMER]
			PX[12] = 0
			PX[13] = 0
			PX[14] = 0
			
			EXTERNAL interrupt

			nothing needs to be done, can be safely ignored
			but OS probably should utilize it to keep track of passed time

		[INTERRUPTS:HANDLER:PAGE_FAULT]
			PX[12] = address that caused page fault
			PX[13] = 0
			PX[14] = 0

			generated if there is no valid mapping for address that CPU tries to access
			writes to memory and to register are prevented from occurring
			
			PX[11] (address) depends on what caused page fault
				memory access with immediate that has been extended by XWR UI =>
					address of preceding XWR
				all else =>
					address of instruction that caused page fault
					instruction fetch is considered part of new instruction, not preceding one


		[INTERRUPTS:HANDLER:PRIVILEGE_VIOLATION]
			PX[12] = instruction that was supposed to execute
			         (NOT address of)
			PX[13] = required privilege level
			PX[14] = 0
			
			generated if CPU tries to execute instruction requiring higher privilege mode

		[INTERRUPTS:HANDLER:PERMISSION_VIOLATION]
			PX[12] = address that CPU tried to access in some way
			PX[13] = type of violation
				0 - read
				1 - write
				2 - execute
			PX[14] = 0

			generated if CPU tries to access page in illegal way

		[INTERRUPTS:HANDLER:DIVISION_BY_0]
			PX[12] = 0
			PX[13] = 0
			PX[14] = 0

			can be generated only if [EXTENSIONS:D] is available
			generated when divisor = 0 

		[INTERRUPTS:HANDLER:IO_INTERRUPT]
			PX[12] = port # 
			PX[13] = type of action needed 
				0 - read from port
				1 - write to port
			PX[14] = 0

			EXTERNAL interrupt

			generated by IO that requires attention
			further communication can be achieved via port PX[12]

		[INTERRUPTS:HANDLER:INSTRUCTION_NOT_SUPPORTED]
			PX[12] = byte sequence that CPU tried to execute
			PX[13] = 0
			PX[14] = 0

			generated if byte sequence is not a valid instruction or requires extension
			note that CPU does not distinguish between the two

		[INTERRUPTS:HANDLER:SOFTWARE_INTERRUPT]
			PX[12] = R[0]
			PX[13] = R[1]
			PX[14] = R[2]
			TO BE FINISHED
			not sure whether to take advantage of that

			only 3 registers are saved

[EXTENSIONS]
	[EXTENSIONS:M] Multiply
		allows to multiply 2 integers
	
	[EXTENSIONS:D] Divide
		allows to divide 2 integers
	
	[EXTENSIONS:C] Conditional move
		allows to perform conditional move instead of jump
		useful for performance reasons when jump would be too expensive

	[EXTENSIONS:P] Programmable instructions
		TO BE FINISHED

	[EXTENSIONS:B] Big Int
		TO BE FINISHED

	within [REGISTERS:EXTERNAL:CF] flags are organized as follows:
		MSb: P000000B 0000CRDM :LSb

[PERFORMANCE_MEASUREMENT]
	TO BE FINISHED
	[PERFORMANCE_MEASUREMENT:GENERAL]
		by setting privileged FF, interrupt can be issued whenever a counter overflows
		dedicated instruction to clear all regs 		

	[PERFORMANCE_MEASUREMENT:REGISTERS]
		cycles
			32bit pair
			increments every cycle
		imiss 
			16bit
			cache misses on instruction
		dmiss
			16bit
			cache misses on data access
		i tlb miss,
			16bit
			tlb misses from instruction access
		d tlb miss,
			16bit
			tlb misses from data access
		fetch
			16bit
			instructions fetched
		exec
			16bit
			instructions executed
		cycles_executing
			32bit pair
			cycles spent executing instructions
		cycles_fetching
			32bit pair
			cycles spent fetching instructions
		d mem ref
			16bit
			memory references for data
		i mem ref
			16bit
			memory references for instruction
		i_branch 
			16bit
			branches executed
		i_branch_t
			16bit
			branches taken
		i_branch_mis
			16bit
			branches mispredicted
		exec_cycles
			16bit
			cycles spent executing
		i_alu
			16bit 
			alu operations executed
		i_mov
			16bit 
			moves executed
		i_xra
			16bit
			external register accessed explicitly
		i_cal
			16bit
			calls
		i_stk
			16bit
			stack operations
		int
			16bit
			interrupt #
		time
			16bit
			ms seconds passed
		ports accessed
			16bit 
			port access count
		regular mode
			32bit pair
			cycles spent in regular execution
		interrupt mode
			32bit pair
			cycles spent servicing interrupt
		ucode mode
			32bit pair
			cycles spent handling ucode routines



			

[INSTRUCTIONS]
	[INSTRUCTIONS:ADD] ADD
		opcode: 10101 
		format: 
			add D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			add D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 
		
		performs arithmetic addition on operands
		stores result in destination (first) register

		R[D] <-- R[D] + R[S]
		R[D] <-- R[D] + I

		if [CPU_FEATURES:BIG_INT] is enabled  
			acts like ADC
			that is, performs operand0 + operand1 + C
			where C is carry flag 

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]

			
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:AND] AND
		opcode: 11011
		format: 
			and D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			and D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical AND on operands
		stores result in destination (first) register

		R[D] <-- R[D] & R[S]
		R[D] <-- R[D] & I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	
			
	[INSTRUCTIONS:CAL] CALL
		opcode: 
	 		cal S   => 10101010
			cal I11 => 00010 
		format: 
			cal S   => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]
			cal I11 => [INSTRUCTION_FORMAT:SHORT_OPCODE:IMMEDIATE]

		stores current IP (address of NEXT instruction) into LR
		performs relative jump to the address specified by operand

		LR <-- IP ; IP <-- IP + R[S]
		LR <-- IP ; IP <-- IP + I 

		Proffered method of calling procedures

		uses UI register in IMMEDIATE format 
		see [INSTRUCTION_FORMAT:IMMEDIATE]

		if previous instruction wrote to UI then immediate is combined UI and from instruction (highest 3 bits are ignored!!)
		otherwise immediate is sign extended


		external registers affected:
			IP, LR
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:CMP] COMPARE
		opcode: 10001
		format:
			cmp D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			cmp D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		subtracts second operand from first
		DOES NOT store results

		R[D] - R[S]
		R[D] - I

		if [CPU_FEATURES:BIG_INT] is enabled  
			acts like SBB
			that is, performs operand0 - (operand1 + C)
			where C is carry flag 

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - signed overflow occurred 
			C - unsigned overflow occurred
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:DIV] DIVIDE
		opcode: 10010 
		format:
			div D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG]
			div D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM]

		divides first operand by second
		stores integer part of the result into destination (first) register

		R[D] <-- int(R[D] / R[S])
		R[D] <-- int(R[D] / I)

		if second operand equals 0, raises interrupt #4
			see [INTERRUPTS]

		if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
			treats operands as signed
		else
			treats operands as unsigned

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			[EXTENSIONS:D]
		privilege level:
			unprivileged	

	[INSTRUCTIONS:HCF] HALT AND CATCH FIRE
		opcode: 00001011
		format: 
			hcf => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		disables interrupts
		halts processor
		there is no way to resume execution

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INSTRUCTIONS:HLT] HALT
		opcode: 00001010
		format:
			hlt => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		enables interrupts
		halts processor
		processor is resumed when an interrupt occurs

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INSTRUCTIONS:INT] INTERRUPT
		opcode: 00001000
		format:
			int I8 => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		raises interrupt of id = operand
			
		affects PX[10..14]
		see [INTERRUPTS] for details about interrupts
	
		flags set:
			-
		external registers affected:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:IRT] INTERRUPT RETURN
		opcode: 00001001
		format:
			irt => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		returns from interrupt
		see [INTERRUPTS] for details about interrupts

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INSTRUCTIONS:JCS] JUMP CONDITIONAL SIGNED
		opcode: 00101
		format: 
			jsc LEG I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:JMP_CCC]

		if the condition is true, performs relative jump to offset specified by operand
		to jump on condition, following must occur:
		(individual letters refer to flags in FL)
			LEG = 000 => jump cannot occur
			LEG = 001 => S  = O AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => S  = O
			LEG = 100 => S /= O
			LEG = 101 => Z /= 0
			LEG = 110 => S /= O ORR Z /= 0
			LEG = 111 => jump occurs always

		uses UI register
		see [INSTRUCTION_FORMAT:IMMEDIATE]

		if previous instruction wrote to UI then immediate is combined UI and from instruction
		otherwise immediate is sign extended

		flags set:
			-
		external registers affected:
			IP
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:JCU] JUMP CONDITIONAL UNSIGNED
		opcode: 00100
		format:
			JCU LEG I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:JMP_CCC]

		if the condition is true, performs relative jump to offset specified by operand

		to jump on condition, following must occur:
		(individual letters refer to flags in FL)
			LEG = 000 => jump cannot occur
			LEG = 001 => C  = 0 AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => C  = O
			LEG = 100 => C /= O
			LEG = 101 => Z /= 0
			LEG = 110 => C /= O ORR Z /= 0
			LEG = 111 => jump occurs always

		uses UI register
		see [INSTRUCTION_FORMAT:IMMEDIATE]

		if previous instruction wrote to UI then immediate is combined UI and from instruction
		otherwise immediate is sign extended

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:JMP] JUMP
		opcode: 
			jmp S   => 10101011
			jmp I11 => 00011
		format:
			jmp S   => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]
			jmp I11 => [INSTRUCTION_FORMAT:SHORT_OPCODE:IMMEDIATE]

		performs relative jump by offset specified in operand

		IP <-- IP + R[S]
		IP <-- IP + I

		uses UI register in IMMEDIATE format 
		see [INSTRUCTION_FORMAT:IMMEDIATE]

		if previous instruction wrote to UI then immediate is combined UI and from instruction (highest 3 bits are ignored!!)
		otherwise immediate is sign extended

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:MCS] MOVE CONDITIONAL SIGNED
		opcode: 10111
		format:
			mcc SOCZ D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:MOV_CCC]

		if condition is true, assigns 2nd operand into 1st operand 

		to move on condition, following must occur:
		(individual letters refer to flags in FL)
			LEG = 000 => move cannot occur
			LEG = 001 => S  = O AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => S  = O
			LEG = 100 => S /= O
			LEG = 101 => Z /= 0
			LEG = 110 => S /= O ORR Z /= 0
			LEG = 111 => move occurs always


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:MCU] MOVE CONDITIONAL UNSIGNED
		opcode: 10110
		format: 
			MCS LEG D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:MOV_CCC]

		if condition is true, assigns 2nd operand into 1st operand 

		to move on condition, following must occur:
		(individual letters refer to flags in FL)
			LEG = 000 => move cannot occur
			LEG = 001 => C  = 0 AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => C  = O
			LEG = 100 => C /= O
			LEG = 101 => Z /= 0
			LEG = 110 => C /= O ORR Z /= 0
			LEG = 111 => move occurs always


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	


	[INSTRUCTIONS:MOV] MOVE
		opcode: 10100
		format:
			mov D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mov D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		stores second operand into first operand
		
		R[D] <-- R[S]
		R[D] <-- I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:MRD] MEMORY READ
		opcode: 01100
		format:
			mrd D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mrd D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		stores memory at address stored by second operand into first operand

		R[D] <-- M[R[S]]
		R[D] <-- M[I]

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:MRO] MEMORY READ OFFSET
		opcode: 01110
		format:
			mro D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mro D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		adds OF and second operand
		stores memory stored at computed address into first operand

		R[D] <-- M[OF + R[S]]
		R[D] <-- M[OF + I]

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:MUL] MULTIPLY
		opcode: 10000
		format:
			mul D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mul D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		multiplies first and second operand
		stores result into destination (first) register

		R[D] <-- R[D] * R[s]
		R[D] <-- R[D] * I

		if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
			treats operands as signed
		else
			treats operands as unsigned

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			[EXTENSIONS:M]
		privilege level:
			unprivileged	

	[INSTRUCTIONS:MWR] MEMORY WRITE
		opcode: 01101
		format:
			mwr D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mwr D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		stores second operand into memory at stored by first operand

		M[R[D]] <-- R[S]
		M[R[D]] <-- I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:MWO] MEMORY WRITE OFFSET
		opcode: 01111
		format:
			mwo D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mwo D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		adds OF and first operand
		stores second operand into memory at computed address

		M[OF + R[D]] <-- R[S]
		M[OF + R[D]] <-- I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:NOP] NO OPERATION
		opcode: 10101111
		format:
			nop => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		does nothing

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:NOT] NOT
		opcode: 11010
		format:
			not D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			not D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical NOT on source (second) operand
		stores result in destination (first) register

		R[D] <-- ~ R[S]
		R[D] <-- ~ I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:ORR] OR
		opcode: 11100
		format:
			orr D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			orr D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical OR on operands
		stores result in destination (first) register

		R[D] <-- R[D] | R[S]
		R[D] <-- R[D] | I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:POP] POP
		opcode: 10101000
		format: 
			pop D => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]

		sets destination to value pointed at address stored by SP
		increments SP

		R[D] <-- M[SP] ; SP <-- SP + 1

		flags set:
			-
		external registers affected:
			SP
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:PRD] PORT READ
		opcode: 01000
		format:
			prd D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			prd D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		reads data from port indicated by second operand into first operand writes

		R[D] <-- P[S]
		R[D] <-- P[I]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INSTRUCTIONS:PSH] PUSH
		opcode: 10101001
		format:
			psh S => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]

		decrements SP
		sets memory pointed at address stored by SP to source register

		SP <-- SP - 1 ; M[SP] <-- R[S] 

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:PWR] PORT WRITE
		opcode: 01001
		format:
			pwr S, D => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			pwr S, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		writes source register into port indicated by second operand into

		P[D] <-- R[S]
		P[I] <-- R[S]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INSTRUCTIONS:PXR] PRIVILEGED EXTERNAL REGISTER READ
		opcode: 00001110
		format:
			pxr D, I => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM] 

		reads value of privileged external register into first operand

		R[D] <-- PX[I]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INSTRUCTIONS:PXW] PRIVILEGED EXTERNAL REGISTER WRITE
		opcode: 00001111
		format:
			pxr I, S => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM] 

		stores second operand into privileged external register indicated by first operand

		PX[I] <-- R[D]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INSTRUCTIONS:RET] RETURN
		opcode: 10101100
		format:
			ret SOCZ => [INSTRUCTION_FORMAT:LONG_OPCODE:RET_FLAGS]

		jumps to LR
		sets flags to SOCZ

		IP <-- LR
		FL <-- SOCZ

		flags set:
			SOCZ - copied from instr format
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:SHL] SHIFT LEFT
		opcode: 11110 
		format:
			shl D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			shl D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs SHIFT LEFT on first operand by value of second operand
		inserts 0s from the right
		stores result in destination (first) register

		if second operand > 15
			effectively zeroes out destination

		R[D] <-- R[D] << R[S]
		R[D] <-- R[D] << I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[INSTRUCTIONS:SHR] SHIFT RIGHT
		opcode: 11111
		format:
			shr S, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			shr S, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs SHIFT RIGHT on first operand by value of second operand
		inserts 0s or 1s (see below) from the left
		stores result in destination (first) register

		R[D] <-- R[D] >> R[S]
		R[D] <-- R[D] >> I

		if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
			inserts signed bit
		else
			inserts 0

		if second operand > 15
			if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
				sets all bits of destination to value of sign bit
			else
				zeroes out destination

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			[EXTENSIONS:M]
		privilege level:
			unprivileged	

	[INSTRUCTIONS:SUB] SUBTRACT
		opcode: 11001
		format:
			sub D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			sub D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		subtracts second operand from first
		stores results into destination (first) register

		R[D] <-- R[D] - R[S]
		R[D] <-- R[D] - I

		if [CPU_FEATURES:BIG_INT] is enabled  
			acts like SBB
			that is performs operand0 - (operand1 + C)
			where C is carry flag 

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - signed overflow occurred 
			C - unsigned overflow occurred
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[TST] TEST
		opcode: 10011
		format:
			tst D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			tst D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical AND on operands
		DOES NOT store result 

		R[D] & R[S]
		R[D] & I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[XOR] XOR
		opcode: 11101
		format:
			xor D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			xor D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical XOR on operands
		stores result in destination (first) register

		R[D] <-- R[D] ^ R[S]
		R[D] <-- R[D] ^ I

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[XRD] EXTERNAL REGISTER READ
		opcode: 01010
		format:
			xrd D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 

		reads external register into destination (first) operand
		E[D] <-- R[S]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[XWR] EXTERNAL REGISTER WRITE
		opcode: 01011
		format:
			xwr D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			xwr D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		sets external register (first operand) to second operand
	
		E[D] <-- R[S]	
		E[D] <-- I	

		uses UI register in REG_IMM format
		see [INSTRUCTION_FORMAT:IMMEDIATE]


		flags set:
			potentially any
		external registers affected:
			potentially any
		required extensions:
			-
		privilege level:
			unprivileged	


[EXPERIMENTAL]
	additional instruction that specifies predication for next N instructions
	PRE CCC COUNT
	COUNT MAX = 16
	can save time because of BP, does not pollute BP with highly unpredictable 

	OS support to force enable/disable F1 F2 features and CF flags
	if bug occurs, OS can disable feature such that an error cannot occur
	OS can also *pretend* that feature is present and emulate instruction in SW

	ret popping stuff from stack

	pop/psh for XR
