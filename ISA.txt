BEFORE PUSHING SEARCH FOR 
	TO BE FINISHED
	remove EXPERIMENTAL
REMOVE/FIX ALL 


[OVERVIEW]
	version:            0 
	codename:           16b40
	this doc revision:  0 
	
	future ISA versions will be backwards compatible unless bug is found 
	if ISA introduces breaking change, it will be stated very clearly 

	negative numbers are represented in Two's complement form
	
[INSTRUCTION_OVERVIEW]
	number in the opcode in hex
	fields with no instructions intentionally left blank
	 programs MUST NOT depend on their behavior since in the future the ISA may be extended
	
    ##      P E
	00                              	#  
	01 000      int    imm8         	# interrupt imm8 
	01 001  P   irt    ----         	# return from interrupt
	01 010  P   hlt    ----         	# halts processor, waits for interrupts
	01 011  P   hcf    ----         	# halts processor completely 
	01 100                          	# 
	01 101                          	# 
	01 110  P   pxr    d, imm5      	# R[d] <-- PX[imm5]
	01 111  P   pxw    imm5, s      	# PX[imm5] <-- R[s] 
	02          cal       imm11     	# LR <-- IP ; IP <-- IP + imm16
	03          jmp       imm11     	# IP <-- IP + imm16
	04          jcu LEG   imm8      	# IF(flags) { IP <-- IP + imm16 } 
	05          jcs LEG   imm8      	# IF(flags) { IP <-- IP + imm16 }
	06 000    P                     	# programmable instruction #0
	   ...
	07 111    P                     	# programmable instruction #F
	08      P   prd       d, s/imm8 	# R[d] <-- P[R[s]/imm16]
	09      P   pwr       d/imm8, s 	# P[R[d]/imm16] <-- R[d]
	0A          xrd       d, s      	# R[d] <-- E[s]
	0B          xwr       d, s/imm8 	# E[d] <-- R[s]/imm16
	0C          mrd       d, s/imm8 	# R[d] <-- M[R[s]/imm16]
	0D          mwr       d/imm8, s  	# M[R[d]/imm16] <-- R[s]
	0E        R mro       d, s/imm8 	# R[d] <-- M[R[s]/imm16 + OF]
	0F        R mwo       d/imm8, s 	# M[R[d]/imm16 + OF] <-- R[s]
	10        M mul       d, s/imm8 	# R[d] <-- R[d] *  R[s]/imm16
	11          cmp       d, s/imm8 	#          R[d] -  R[s]/imm16
	12        D div       d, s/imm8 	# R[d] <-- R[d] /  R[s]/imm16
	13          tst       d, s/imm8 	#          R[d] &  R[s]/imm16
	14          mov       d, s/imm8 	# R[d] <-- R[s]/imm16
	15 000      pop       d         	# R[d] <-- M[SP] ; SP <-- SP + 1 
	15 001      psh          s      	# SP <-- SP - 1 ; M[SP] <-- R[s]
	15 010      cal       s         	# LR <-- IP ; IP <-- IP + R[s] 
	15 011      jmp       s         	# IP <-- IP + R[s]
	15 100      ret       SOCZ      	# IP <-- LR; FL <-- SOCZ
	15 101                          	# 
	15 110                          	# 
	15 111      nop                 	# --------
	16        C mcu LEG   d, s      	# IF(flags) {R[d] <-- R[s]}
	17        C mcs LEG   d, s      	# IF(flags) {R[d] <-- R[s]}
	18          add       d, s/imm8 	# R[d] <-- R[d] +  R[s]/imm16
	19          sub       d, s/imm8 	# R[d] <-- R[d] -  R[s]/imm16
	1A          not       d, s/imm8 	# R[d] <--      ~  R[s]/imm16
	1B          and       d, s/imm8 	# R[d] <-- R[d] &  R[s]/imm16
	1C          orr       d, s/imm8 	# R[d] <-- R[d] |  R[s]/imm16
	1D          xor       d, s/imm8 	# R[d] <-- R[d] ^  R[s]/imm16
	1E          shl       d, s/imm8 	# R[d] <-- R[d] << R[s]/imm4
	1F          shr       d, s/imm8 	# R[d] <-- R[d] >> R[s]/imm4

	where:
	M[x]  means memory at address x
	R[x]  means value of register x
	E[x]  means value of external register x
	P[x]  means value of port x
	PX[x] means value of privileged access external register x 

	P in the P column implies that instruction has to be executed in privileged mode
	Letter in E column identifies [EXTENSIONS] necessary to run instruction

#thanks to VM, more than 64kiB of mem can be used

[EXTENSIONS]
	[M] Multiply
		allows to multiply 2 integers
	
	[D] Divide
		allows to divide 2 integers

	[R] memory Relative
		allows to use [EXTERNAL_REGISTERS:OF] as offset to memory references
		useful to access fields of struct by first loading struct address into OF 
		then accessing using constant offset
	
	[C] Conditional move
		allows to perform conditional move instead of jump
		useful for performance reasons when jump would be too expensive

	[P] Programmable instructions
		TO BE FINISHED

	within [EXTERNAL_REGISTERS:CF] flags are organized as follows:
		MSb: P000000B 0000CRDM :LSb

[REGISTERS]
	[REGULAR]
		there are 8 registers available to be used in most of the instructions
		denoted by R[x] in instruction description 
		
		0 - R0 ; GPR 0
		1 - R1 ; GPR 1
		2 - R2 ; GPR 2
		3 - R3 ; GPR 3
		4 - R4 ; GPR 4
		5 - R5 ; GPR 5
		6 - R6 ; GPR 6
		7 - R7 ; GPR 7

[EXTERNAL_REGISTERS]
	[LIST]
		0 IP Instruction Pointer
		1 CF Cpu Flags (during Read)
		1 UI Upper Immediate (during Write)
		2 LR Link Register
		3 SP Stack Pointer
		4 OF OFfset register
		5 FL FLags
		6 F1 Feature enable 1  
		7 F2 Feature enable 2 

	[IP] Instruction Pointer
		holds address of NEXT instruction
		writing to this register is equivalent to unconditional jump
			this is the only way to perform jump to absolute address

		if instruction was any of: INT, JMP CAL 
		or if instruction was JCS or JCU and the jump occured 
		or if instruction was WRX IP, /*something*/
		then value of IP is changed by that instruction
		otherwise, it is incremented by 1 

	[CF] CPU flags
		this register cannot be written into

		each bit contains info whether an extension is available
		see [CPU_FEATURES]

	[UI] Upper Immediate
		this register cannot be read from directly
		it is possible to retrieve the value by using MOV R, IMM ; SHR R, 8

		extends range of immediate by adding additional 8 bits
		note that some instructions may ignore extended part completely
		cleared on each cycle it is not updated by instruction
		see [IMMEDIATES] for details
	
	[LR] Link Register
		used implictly by CAL and RET
		CAL stores value of IP during CAL into LR
		in other words, CAL stores address of FOLLOWING instructions into LR

		see [CALLING_CONVENTION]

	[SP] Stack Pointer
		used implicitly by POP and PSH

		see [STACK]

	[OF] OFfset register
		available if [EXTENSIONS:R] is available
		used implictitly by MRO and MWO to access memory

	[FL] FLags register
		contains 4 flag bits
		 00000000 0000SOCZ
		 S - most significant bit (sign) on 
		 O - signed overfow, defined for ADD, SUB, CMP
		 C - unsigned overflow, defined for ADD, SUB, CMP
		 Z - all bits = 0 
		 

	[F1] Feature enable 1
		contains bit used to enable/disable particular feature, if available
		unused bits are reserved and their value should not be changed

		see [CPU_FEATURES]

	[F2] Feature enable 2
		contains bit used to enable/disable particular feature, if available
		unused bits are reserved and their value should not be changed

		see [CPU_FEATURES]

[IMMEDIATES]
	immediates can be extended with UI external register
	first immediate is zero extendend to 16bits
	then lower 8 bits of UI are ored into higher 8bits of immediate

	some instructions that ignore UI even though they use immediate
	WRX UI is then effectively NOP

	for most instructions this works as expected because the immediate is 8 bits
	JMP and CAL however have 11bit immediate
	to achieve intuitive results
	 upper 3 bits in JMP and CAL's immediate should be 0 
	 whenever they are preceeded by WRX UI
	for example, these result in the same immediate being used:
		WRX UI, 0x7
		JMP 0xFF

		JMP 0x7FF

[INSTRUCTION_FORMAT]
	IMPORTANT:
		bits in the immediate are encoded as follows
			let X be length of immediate
			MSb: X-2...0 X-1 :LSb
		in other words, Most significant bit comes LAST in the encoding
		all other bits are in the decreasing order
		for example, bits for 8bit immediate are organized like this:
			65432107

		rationale: simplifies sign extension 

	[LONG_OPCODE]
		this instructions have opcode 0x0, 0x6 and 0x7 and 0x15 in [SHORT_OPCODE] format
	
		[IMMEDIATE]
			OOOOOOOO IIIIIIII	
				O - opcode 
				I - imm8 

			used by:
				INT, IRT, HLT, HCF, NOP
				note that IRT, HLT, HCF, NOP ignore immediate, it should be set to 0

		[REG_IMM]
			OOOOOOOO RRRIIIII
				O - opcode
				R - register id 
				I - imm5 
				
			used by:
				PXR, PXW, POP, PSH, CAL, JMP
				note that POP, PSH, CAL, JMP ignore immediate, it should be set to 0
				          this refers to CAL and JMP in register format

		[RET_FLAGS]
			OOOOOOOO FFFF0000
				O - opcode
				F - SOCZ 
				0 - must be set to 0
				
			used by:
				RET


	[SHORT_OPCODE]

		[LONG_IMMEDIATE]
			OOOOOIII IIIIIIII
				O - opcode
				I - imm11

			used by:
				JMP, CAL
				note that this refers to immediate version of these instructions
		
		[JMP_CCC]
			OOOOOIII IIIIFFFI
				O - opcode
				I - imm7
				F - flags, in order from MSb to LSb: SOCZ

			used by:
				JCS, JCU

		[MOV_CCC]
			OOOOOSSS DDD0FFF0
				O - opcode
				S - source register id
				D - destination register id
				F - flags, in order from MSb to LSb: SOCZ
				0 - MUST be 0
			
			used by:
				MCC, MNC

		[REG_IMM]
			OOOOOIII RRRIIIII
				O - opcode
				I - imm8
				R - register

			used by:
				PRD, PWR,      XWR, MRD, MWD, MRO,
				MWO, MUL, CMP, DIV, TST, MOV, ADD,
				SUB, NOT, AND, ORR, XOR, SHL, SHR
				note that this refers to immediate version of these instructions

		[REG_REG]
			00000SSS DDDOOOOO
				0 - MUST be set to 0
				S - source register
				D - destination register
				O - opcode

			used by:
				PRD, PWR, XRD, XWR, MRD, MWD, MRO,
				MWO, MUL, CMP, DIV, TST, MOV, ADD,
				SUB, NOT, AND, ORR, XOR, SHL, SHR
				note that this refers to register version of these instructions
		
		


[CPU_FEATURES]
	F1: 00000000 00000sSB
	F2: 00000000 0000000P

	B [Big int] 
		switch behavior of ADD and SUB to ADC and SBC
	P [self modifying code Protection]
		when disabled, self modifying code MAY not work 
		but performance MAY improve
	S [Sign extension]
		when enabled, immediates get sign extendend
		if an immediate is negative then immediate extension via [EXTERNAL_REGISTER:UI] may not behave as expected 
	s [Signed arithmetic]
		when enabled MUL, DIV and SHR treat operands as signed 
		does not apply to ADD and SUB which behave the same way either way


[MEMORY]
	memory is word addressable, where each word is 2Bytes
	
	at leat 64kiW (128kiB) is available

	memory can be accessed directly with:
		MRD MWD MRO MWO 
	or indirectly with
		PSH POP


	[STACK]
		managed implicitly by POP and PSH
		SP points to the top of the stack
			NOT to where next value should go

		POP first gets value THEN increments SP
		PSH first decrements SP THEN puts value
		
		if [EXTENSIONS:R] is available
		local variables can easily be accessed with [EXTERNAL_REGISTER:OF] set to SP

	[PHYSICAL MEMORY MAP]
		0x0000 - 0x

[PRIVILEGE_LEVEL]
	controlled by PX[0]

	currently, there are 2 modes available
	supervisor mode (also refered to as privileged mode)
	 enabled by writing 00000000 00000000 into PX[0]
	user mode, (also refered to as unprivileged mode)
	 enabled by writing 00000000 00000011 into PX[0]

	the only instruction that can change privilege level in user mode is INT
	


[OPERATING_SYSTEM]
	TO BE FINISHED
	[IMPLEMENTATION]

	[ADVICE]
		kernel should provide some functions always mapped and accessible for user progams to avoid overhead of system calls

[IO]
	TO BE FINISHED
	preffered method of communication with devices 

	devices and OS use port 0 to decide which ports are to be used 

[INTERRUPT]
	while there is distinction between exceptions and interrupts
	this ISA treats them the same and thus they are collectively refered to as interrupts
	
	interrupt can be external or internal generated by INT or exception during some instruction execution 

	[LIST]
		0 to 63   - HW defined (unused are reserved)
		64 to 255 - available to SW 
			OS can set them up for various syscalls instead of wasting register to decide that 

		0 -  
		1 - page fault
		2 - privilege violation (privileged instruction in unprivileged mode)
		3 - permission violation (unallowed read/write/execute)
		4 - division by 0  
		5 - IO interrupt
		6 - instruction not supported
		7 - double fault
			TO BE FINISHED

	[INTERRUPT_RAISED]
		source of interrupt does not matter, basic handling looks the same 
		it may happen that several interrupts are to be raised, in which case, the lowest number takes priority

		during interrupt causing event:
			interrupts are disabled
			privilege level is raised 
			FL, UI are saved to internal registers
			PX[10] = interrupt id
			PX[11] = address of instruction following the one that generated this interrupt 
			PX[12...14] = interrupt depependent info 

			interrupt handler at 
			

	[INTERRUPT_HANDLED]
		the only way to finish interrupt handling is via IRT
		OS may save IP for its own use and then modify PX[11]
		this way, longer syscalls can be implemented without disabling interrupts for too long

		during IRT
			privilege level is decreased 
			FL, UI are restored
			IP is restored from PX[11]
			interrupts are enabled
		
		note that IRT jumps back to PX[11] which is the address of instruction FOLLOWING the one that caused interrupt
		if it is necessary to replay instruction, PX[11] should be decremented

	[DETAILED_INTERRUPTS]
		[PAGE_FAULT]
			PX[12] = address that caused page fault
			PX[13] = 0
			PX[14] = 0

			generated if there is no valid mapping for address that CPU tries to access

		[PRIVILEGE_VIOLATION]
			PX[12] = instruction that was supposed to execute
			         (NOT address of)
			PX[13] = 0
			PX[14] = 0
			
			generated if CPU in user mode tries to execute instruction requiring 

		[PERMISSION_VIOLATION]
			PX[12] = address that CPU tried to access in some way
			PX[13] = type of violation
				0 - read
				1 - write
				2 - execute
			PX[14] = 0

			generated if CPU tries to access page in illegal way

		[DIVISION_BY_0]
			PX[12] = 0
			PX[13] = 0
			PX[14] = 0

			can be generated only if [EXTENSIONS:D] is available
			generated when divisor = 0 

		[IO_INTERRUPT]
			PX[12] = port # 
			PX[13] = 0
			PX[14] = 0

			generated by IO that requires attention
			further communication can be achieved via port PX[12]

		[INSTRUCTION_NOT_SUPPORTED]
			PX[12] = byte sequence that tried to execute
			PX[13] = 0
			PX[14] = 0

			generated if byte sequence is not a valid instruction or requires extension
			note that CPU itself does not distinguish between the two


[VIRTUAL_MEMORY]
	consider smaller pages
	TO BE FINISHED
virtual memory
	OS sets up its own page table
	saves address of PT to PX[1]
	then performs any write to PX[31]
	after that, IP is changed to 0x0000 (like on boot) but this page MUST be mapped to frame
	if it is not then behavior is undefined 

	page
		each page is 4kiB in size, thus full PT stores mapping for 16 pages

	page table format

		at 0x0000:
		16b entry with PID 

		at 0x0010:
		16 entries, 1 for each page, ordered 
		[present] [read] [write] [execute] [frame #]
		      1b     1b      1b        1b       12b 

		note that if frame # exceeds physically available pages, the behavior is undefined
		os should make sure that a particular page is available via checking contents of PX[2]
		however, ISA guarantees that at least 64kiB are available (PX[2] >= 64)

	
	page fault (page not present in page table)
		if program attempts to access address that is not present in page table,
		interrupt is generated and the control is passed to OS

	
	for convienience, OS should always be able to access its page table (and other crucial data)
	additionally it is useful to mark 1 page (usually 0th) as invalid for each process to prevent uninitialized pointer access
	therefore it is recommended that OS page table is stored at both virtual and physical 0x0000

[PROGRAM_LAYOUT]
	TO BE FINISHED

[BOOT]
	TO BE FINISHED
	boot:
		machine starts executing instructions from 0x0000 in privileged, unpaged mode



[PRIVILEGED_EXTERNAL_REGISTERS]
	to access any of these, PX[0] MUST equal 00
	unused registers MUST NOT be used, they are reserved for future use

	[LIST]
		00 privilege level
		01 page table address 
		02 available memory (in kiW)
		03 
		04
		05
		06
		07
		08
		09
		10 interrupt info: id
		11 interrupt info: IP
		12 interrupt info: interruptdependent0
		13 interrupt info: interruptdependent1
		14 interrupt info: interruptdependent2
		15
		16
		17
		18
		19
		20 
		21 
		22
		23
		24
		25
		26
		27
		28
		29
		30
		31 update state, special write only register, causes update to machine state (reread of state registers, reread of PT) 

	[DESCRIPTION]
		PX[ 0]
			used to determine privilege level

			see [PRIVILEGE_LEVE]
		PX[ 1]
			page table address

			see [VIRTUAL_MEMORY]
		PX[ 2]
		PX[10] 
			interrupt ID

			see [INTERRUPT]
		PX[11] 
			IP saved by interrupt

			see [INTERRUPT]
		PX[12] 
			interrupt info 

			see [INTERRUPT]
		PX[13]
			interrupt info 

			see [INTERRUPT]
		PX[14]
			interrupt info 

			see [INTERRUPT]
		PX[31]
			state update
			write causes update of machine state
			necessary after write to other PX that modifies machine state
			(or after write to several PX)
			

[INSTRUCTION_EXPLANATION]
	[ADD] ADD
		opcode: 10101 
		format: 
			add D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			add D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 
		
		performs arithmetic addition on operands
		stores result in destination (first) register

		R[D] <-- R[D] + R[S]
		R[D] <-- R[D] + I

		if [CPU_FEATURES:BIG_INT] is enabled  
			acts like ADC
			that is performs operand0 + operand1 + C
			where C is carry flag 

		uses UI register in REG_IMM format
		see [IMMEDIATES]

			
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[AND] AND
		opcode: 11011
		format: 
			and D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			and D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical AND on operands
		stores result in destination (first) register

		R[D] <-- R[D] & R[S]
		R[D] <-- R[D] & I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	
			
	[CAL] CALL
		opcode: 
	 		cal S   => 10101010
			cal I11 => 00010 
		format: 
			cal S   => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]
			cal I11 => [INSTRUCTION_FORMAT:SHORT_OPCODE:IMMEDIATE]

		stores current IP (address of NEXT instruction) into LR
		performs relative jump to the address specified by operand

		LR <-- IP ; IP <-- IP + R[S]
		LR <-- IP ; IP <-- IP + I 

		preffered method of calling procedures

		uses UI register in IMMEDIATE format 
		see [IMMEDIATES]


		external registers affected:
			IP, LR
		required extensions:
			-
		privilege level:
			unprivileged	

	[CMP] COMPARE
		opcode: 10001
		format:
			cmp D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			cmp D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		subtracts second operand from first
		DOES NOT store results

		R[D] - R[S]
		R[D] - I

		if [CPU_FEATURES:BIG_INT] is enabled  
			acts like SBB
			that is performs operand0 - (operand1 + C)
			where C is carry flag 

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - signed overflow occured 
			C - unsigned overflow occured
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[DIV] DIVIDE
		opcode: 10010 
		format:
			div D, S  => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG]
			div D, I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM]

		divides first operand by second
		stores integer part of the result into destination (first) register

		R[D] <-- int(R[D] / R[S])
		R[D] <-- int(R[D] / I)

		if second operand equals 0, raises interrupt #4
			see [INTERRUPT]

		if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
			treats operands as signed
		else
			treats operands as unsigned

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			[EXTENSIONS:D]
		privilege level:
			unprivileged	

	[HCF] HALT AND CATCH FIRE
		opcode: 00001011
		format: 
			hcf => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		disables interrupts
		halts processor
		there is no way to resume execution

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[HLT] HALT
		opcode: 00001010
		format:
			hlt => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		enables interrupts
		halts processor
		processor is resumed when an interrupt occurs

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[INT] INTERRUPT
		opcode: 00001000
		format:
			int I8 => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		raises interrupt of id = operand
			
		affects PX[10..14]
		see [INTERRUPT] for details about interrupts
	
		flags set:
			-
		external registers affected:
			-
		privilege level:
			unprivileged	

	[IRT] INTERRUPT RETURN
		opcode: 00001001
		format:
			irt => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		returns from interrupt
		see [INTERRUPT] for details about interrupts

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[JCS] JUMP CONDITIONAL SIGNED
		opcode: 00101
		format: 
			jsc LEG I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:JMP_CCC]

		if the condition is true, performs relative jump to offset specified by operand
		to jump on condition, following must occur:
		(indidual letters refer to flags in FL)
			LEG = 000 => jump cannot occur
			LEG = 001 => S  = O AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => S  = O
			LEG = 100 => S /= O
			LEG = 101 => Z /= 0
			LEG = 110 => S /= O ORR Z /= 0
			LEG = 111 => jump occurs always

		uses UI register
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			IP
		required extensions:
			-
		privilege level:
			unprivileged	

	[JCU] JUMP CONDITIONAL UNSIGNED
		opcode: 00100
		format:
			JCU LEG I8 => [INSTRUCTION_FORMAT:SHORT_OPCODE:JMP_CCC]

		if the condition is true, performs relative jump to offset specified by operand

		to jump on condition, following must occur:
		(indidual letters refer to flags in FL)
			LEG = 000 => jump cannot occur
			LEG = 001 => C  = 0 AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => C  = O
			LEG = 100 => C /= O
			LEG = 101 => Z /= 0
			LEG = 110 => C /= O ORR Z /= 0
			LEG = 111 => jump occurs always

		uses UI register
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[JMP] JUMP
		opcode: 
			jmp S   => 10101011
			jmp I11 => 00011
		format:
			jmp S   => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]
			jmp I11 => [INSTRUCTION_FORMAT:SHORT_OPCODE:IMMEDIATE]

		performs relative jump by offset specified in operand

		IP <-- IP + R[S]
		IP <-- IP + I

		uses UI register in IMMEDIATE format 
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[MCS] MOVE CONDITIONAL SIGNED
		opcode: 10111
		format:
			mcc SOCZ D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:MOV_CCC]

		if condition is true, assigns 2nd operand into 1st operand 

		to move on condition, following must occur:
		(indidual letters refer to flags in FL)
			LEG = 000 => move cannot occur
			LEG = 001 => S  = O AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => S  = O
			LEG = 100 => S /= O
			LEG = 101 => Z /= 0
			LEG = 110 => S /= O ORR Z /= 0
			LEG = 111 => move occurs always


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[MCU] MOVE CONDITIONAL UNSIGNED
		opcode: 10110
		format: 
			MCS LEG D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:MOV_CCC]

		if condition is true, assigns 2nd operand into 1st operand 

		to move on condition, following must occur:
		(indidual letters refer to flags in FL)
			LEG = 000 => move cannot occur
			LEG = 001 => C  = 0 AND Z  = 0
			LEG = 010 => Z  = 0
			LEG = 011 => C  = O
			LEG = 100 => C /= O
			LEG = 101 => Z /= 0
			LEG = 110 => C /= O ORR Z /= 0
			LEG = 111 => move occurs always


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	


	[MOV] MOVE
		opcode: 10100
		format:
			mov D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mov D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		stores second operand into first operand
		
		R[D] <-- R[S]
		R[D] <-- I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[MRD] MEMORY READ
		opcode: 01100
		format:
			mrd D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mrd D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		stores memory at address stored by second operand into first operand

		R[D] <-- M[R[S]]
		R[D] <-- M[I]

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[MRO] MEMORY READ OFFSET
		opcode: 01110
		format:
			mro D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mro D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		adds OF and second operand
		stores memory stored at computed address into first operand

		R[D] <-- M[OF + R[S]]
		R[D] <-- M[OF + I]

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			[EXTENSIONS:R]
		privilege level:
			unprivileged	

	[MUL] MULTIPLY
		opcode: 10000
		format:
			mul D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mul D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		multiplies first and second operand
		stores result into destination (first) register

		R[D] <-- R[D] * R[s]
		R[D] <-- R[D] * I

		if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
			treats operands as signed
		else
			treats operands as unsigned

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			[EXTENSIONS:M]
		privilege level:
			unprivileged	

	[MWR] MEMORY WRITE
		opcode: 01101
		format:
			mwr D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mwr D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		stores second operand into memory at stored by first operand

		M[R[D]] <-- R[S]
		M[R[D]] <-- I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[MWO] MEMORY WRITE OFFSET
		opcode: 01111
		format:
			mwo D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			mwo D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		adds OF and first operand
		stores second operand into memory at computed address

		M[OF + R[D]] <-- R[S]
		M[OF + R[D]] <-- I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			-
		external registers affected:
			-
		required extensions:
			[EXTENSIONS:R]
		privilege level:
			unprivileged	

	[NOP] NO OPERATION
		opcode: 10101111
		format:
			nop => [INSTRUCTION_FORMAT:LONG_OPCODE:IMMEDIATE]

		does nothing

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[NOT] NOT
		opcode: 11010
		format:
			not D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			not D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical NOT on source (second) operand
		stores result in destination (first) register

		R[D] <-- ~ R[S]
		R[D] <-- ~ I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[ORR] OR
		opcode: 11100
		format:
			orr D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			orr D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical OR on operands
		stores result in destination (first) register

		R[D] <-- R[D] | R[S]
		R[D] <-- R[D] | I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[POP] POP
		opcode: 10101000
		format: 
			pop D => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]

		sets destination to value pointed at address stored by SP
		increments SP

		R[D] <-- M[SP] ; SP <-- SP + 1

		flags set:
			-
		external registers affected:
			SP
		required extensions:
			-
		privilege level:
			unprivileged	

	[PRD] PORT READ
		opcode: 01000
		format:
			prd D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			prd D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		reads data from port indicated by second operand into first operand writes

		R[D] <-- P[S]
		R[D] <-- P[I]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[PSH] PUSH
		opcode: 10101001
		format:
			psh S => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM]

		decrements SP
		sets memory pointed at address stored by SP to source register

		SP <-- SP - 1 ; M[SP] <-- R[S] 

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			unprivileged	

	[PWR] PORT WRITE
		opcode: 01001
		format:
			pwr S, D => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			pwr S, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		writes source register into port indicated by second operand into

		P[D] <-- R[S]
		P[I] <-- R[S]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[PXR] PRIVILEGED EXTERNAL REGISTER READ
		opcode: 00001110
		format:
			pxr D, I => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM] 

		reads value of privileged external register into first operand

		R[D] <-- PX[I]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[PXW] PRIVILEGED EXTERNAL REGISTER WRITE
		opcode: 00001111
		format:
			pxr I, S => [INSTRUCTION_FORMAT:LONG_OPCODE:REG_IMM] 

		stores second operand into privileged external register indicated by first operand

		PX[I] <-- R[D]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			-
		privilege level:
			privileged	

	[RET] RETURN
		opcode: 10101100
		format:
			ret SOCZ => [INSTRUCTION_FORMAT:LONG_OPCODE:RET_FLAGS]

		jumps to LR
		sets flags to SOCZ

		IP <-- LR
		FL <-- SOCZ

		flags set:
			SOCZ - copied from instr format
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[SHL] SHIFT LEFT
		opcode: 11110 
		format:
			shl D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			shl D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs SHIFT LEFT on first operand by value of second operand
		inserts 0s from the right
		stores result in destination (first) register

		if second operand > 15
			effectively zeroes out destination

		R[D] <-- R[D] << R[S]
		R[D] <-- R[D] << I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[SHR] SHIFT RIGHT
		opcode: 11111
		format:
			shr S, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			shr S, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs SHIFT RIGHT on first operand by value of second operand
		inserts 0s or 1s (see below) from the left
		stores result in destination (first) register

		R[D] <-- R[D] >> R[S]
		R[D] <-- R[D] >> I

		if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
			inserts signed bit
		else
			inserts 0

		if second operand > 15
			if [CPU_FEATURES:SIGNED_ARITHMETIC] is enabled
				sets all bits of destination to value of sign bit
			else
				zeroes out destination

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			[EXTENSIONS:M]
		privilege level:
			unprivileged	

	[SUB] SUBTRACT
		opcode: 11001
		format:
			sub D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			sub D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		subtracts second operand from first
		stores results into destination (first) register

		R[D] <-- R[D] - R[S]
		R[D] <-- R[D] - I

		if [CPU_FEATURES:BIG_INT] is enabled  
			acts like SBB
			that is performs operand0 - (operand1 + C)
			where C is carry flag 

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - signed overflow occured 
			C - unsigned overflow occured
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[TST] TEST
		opcode: 10011
		format:
			tst D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			tst D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical AND on operands
		DOES NOT store result 

		R[D] & R[S]
		R[D] & I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[XOR] XOR
		opcode: 11101
		format:
			xor D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			xor D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		performs logical XOR on operands
		stores result in destination (first) register

		R[D] <-- R[D] ^ R[S]
		R[D] <-- R[D] ^ I

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			S - MSb = 1 
			O - undefined but modified
			C - undefined but modified
			Z - all bits are 0 
		external registers affected:
			FL
		required extensions:
			-
		privilege level:
			unprivileged	

	[XRD] EXTERNAL REGISTER READ
		opcode: 01010
		format:
			xrd D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 

		reads external register into destination (first) operand
		E[D] <-- R[S]

		flags set:
			-
		external registers affected:
			-
		required extensions:
			read from OF requires [EXTENSIONS:R]
		privilege level:
			unprivileged	

	[XWR] EXTERNAL REGISTER WRITE
		opcode: 01011
		format:
			xwr D, S => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_REG] 
			xwr D, I => [INSTRUCTION_FORMAT:SHORT_OPCODE:REG_IMM] 

		sets external register (first operand) to second operand
	
		E[D] <-- R[S]	
		E[D] <-- I	

		uses UI register in REG_IMM format
		see [IMMEDIATES]


		flags set:
			potentially any
		external registers affected:
			potentially any
		required extensions:
			write to OF requires [EXTENSIONS:R]
		privilege level:
			unprivileged	


[EXPERIMENTAL]
	additonal instruction that specifies predication for next N instructions
	PRE CCC COUNT
	COUNT MAX = 16
	can save time because of BP, does not pollute BP with highly unpredictable 

	OS support to force enable/disable F1 F2 features and CF flags
	if bug occurs, OS can disable feature such that an error cannot occur
	OS can also *pretend* that feature is present and emulate instruction in SW

	ret popping stuff from stack

	pop/psh for XR
